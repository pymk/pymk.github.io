---
title: "Software Design"
date: "2023-01-07"
image: "software-design.jpg"
categories: [tech]
---

Found a book called *A Philosophy of Software Design* by John Ousterhout and I am thoroughly enjoying it. I will write down the notes in this blog as I continue to read it to help me retain the information and refer back to it.

---

### Code Complexity

A complex code can be identified by the amount of time the developer has to spend learning and understanding the code ("**cognitive load**") in order to make even simple changes.

An example would be when making a simple update requires a lot of code modification throughout the code base. Or when updating part of the code unintentionally changes or breaks something else ("**unknown unknowns**").

In order to reduce complexity, we can do a few things:

1. Having a simpler code
   - Write simple, obvious code vs a clever, more complex one
2. Reduce special cases
   - Helps with reduce cognitive load
3. Abstractions and encapsulation of complexities
   - So developers are only expose to it when needed

The two main culprits of code complexity are **dependencies** and **obscurity**.

An example of dependency would be when a piece of code cannot be modified without having to update other code pieces and making changes.

An example of obscurity would be lack of documentation or when important information in the code is not obvious.

Complexities are introduced incrementally, so a **"zero tolerance" philosophy** (more on this later) is required to stay vigilant.

### Tactical vs Strategic

The book discusses two types of programming: tactical and strategic.

**Tactical programming** is when we quickly push out code just to get the job done or meet a deadline. It is that instant gratification or the fastest way to get something done.

This is the sure way to incur technical debt and, in the long-term, will require more time and effort for maintaining and updating.

**Strategic programming** is when developers spend some time to come up with a design for the system. Think through a few alternative approaches before deciding the right one. When mistakes are identified, they should be fixed rather than patched around it.

### Modular Design and Abstractions

Ideally, each module should be independent of the other ones, so the complexities of a given module are self-contained. But interactivity and dependencies between modules are unavoidable, but the goal should be to minimize these dependencies.

When creating a model, think about the **interface** (what it does) and **implementation** (how it does it) of the module.

The module's interface should be simple to reduce complexity of the overall system. Having a simple interface allows the developer to modify the implementation without affecting modules that are dependent on it.

Abstractions are a way to hide away unimportant information or details that allow for easier understanding of the system. For example, a function that deletes a file can abstract away the exact mechanism of how it does it.

We should strive for **"deep"** module/classes/functions (powerful functionality, but simple interface) rather than **"shallow"** ones (complex interface, but simple functionality). A shallow module does not contribute much functionality, but adds complexity to the system.
